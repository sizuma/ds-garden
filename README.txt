1. 取扱説明 (コンパイル&実行方法)
    bash build.sh でコンパイルとjarファイルの作成できる。(JDK 11が必要)
    java -jar garden.jar 西門の人数 東門の人数 で実行する。
    例えば西門 1000人、東門2000人の場合は
    java -jar garden 1000 2000 とする。

2. 実行結果 (どのような実行結果になるか？)
    java -jar garden 1000 2000 とすると

    Closed all turnstiles
    Counter is 2606
    Turnstiles:
    	西門:1000
    	東門:2000
    sum: 3000

    と表示された。Closed all turnstilesは処理が終わったことを示している。
    Counter is 2606はカウンターの値が2606であったことを示している。
    Turnstiles:以下のインデントされている部分はそれぞれの門で実際に何人が通ったかを示している。
    sum:ではそれぞれの門の実際の人数の合計を示している。

    以上の結果から実際には3000人通過したのにも関わらずカウンターでは2606人しかカウントされていないことがわかる。

3. 考察 (なぜそのような結果になったか？問題点と改善策，類似問題などを書く, 300字以上)
    https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html
    この資料によるとjvmではインスタンス変数のインクリメントはatomicは処理ではないようだ。
    インスタンス変数のインクリメントは
        1. インスタンス変数の読み出し
        2. 加算演算
        3. インスタンス変数の格納
    の3つの動作に分けられる。
    複数のスレッドからインクリメントを同時に実行すると1の読み出しの動作が同時、もしくは逐次的に実行される可能性がある。
    例えば現在の値が100の時にスレッドA,Bが同時にインクリメントを実行すると
        ・ Aが値の読み出し(100)
        ・ Bが値の読み出し(100)
        ・ Aが加算(101)
        ・ Bが加算(101)
        ・ Aが値の代入(101)
        ・ Bが値の代入(101)
    となる可能性がある。こうなると2回のインクリメントが実行されたにも関わらず値が1しか増えていないことがわかる。
    問題点はインクリメントの1~3の動作は本来不可分(atomic)な処理なはずなのに同時に実行してしまっていることだ。
    正しく動作させるには1~3の動作を不可分にする必要がある。javaではsynchronizedでロックをかけたりAtomicInteger#incrementAndGetを使って実現できる。
    この問題はrace condition(競合状態)と言ってマルチスレッドプログラミングの典型的な問題である。